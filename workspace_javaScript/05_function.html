<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        // function 키워드로 시작
        // 함수이름(키워드 빼고 )
        // () {} 
        // ()안에는 전달받을 내용을 담는 변수들
        // return 키워드를 통해 값을 돌려줄 수 있다

        // 함수를 쓰는 이유
        // 1. 정해진 순으로 동작하는 코드의 묶음 
        // 2. 코드의 재사용을 편하게 
         //지역변수  function괄호 안에 있는 z랑 다르므로 사용해도 된다
         let z = 1; 

        function add(x,y){ // ()선언을 의미, 전달받을 내용을 저장할 변수까지 선언
            let z = x + y;
            console.log(z);
            return z;
        }

        let a = 3;
        let b = 7;
        let arr3 = add(a, b); // ()실행을 의미, 전달할 내용을 넣을 수 있음
        console.log('arr3 :',arr3); //undefined 였는데 function안에 return z를 쓰니까 결과가 10이 나옴

        let k = 3;
        let l = 7;
        add(k, l);

        // x라는 이름의 기본 함수
        function x(){

        }

        x();

        //괄호가 붙어있으면 무조건 함수
        //console.log도 괄호 가 붙어있으니까 함수 --실행함수

        //고급기술.. 즉시 실행하는 예제 (아직 몰라도 됨)
        (
            function y(){
                console.log(123)
            }
        )(); 
        
        // 전달인자가 하나인 함수
        let result = sqr(5);
        function sqr(a){
            let b= a*a;
            return b;
        }
        console.log(result); // 25

        // 전달인자가 없는 함수
        function printInfo(){
            console.log("이름 : 홍길동");
            console.log("나이 : 비밀");
        }
       printInfo();

       // 호이스팅 
        function test(){
            console.log('test');
            a3 = 3;
        }
        console.log()

       // 함수안에서 호출하는 함수
    
       // add(x,y), sqr(a)
       // x와 y를 더해서 제곱할 예정
        function fun(first, second){ //first와 second는 변수의 값으로 원하는대로 설정가능
                let result1 = add(first, second);
                let result2 = sqr(result1);

                return result2;
        }
        let result3 = fun(1,2);
        console.log(result3); //9

        console.log("--------------6월 7일 금요일--------------")
        //전달인자는 순서대로 넘어오기 때문에
        //하나만 들어오면 a에 들어감
        //그래서 b에만 전달할 수 없음
        //첫번째 들어오는건 무조건 a이기 때문에 b에만 넣어줄 수는 없다 
        function sum (a, b){
            console.log('a: ',a);
            console.log('b: ',b);
          
            let c;
            if(b){  // false란? false, undefined, null, 0, ''
                    // true란? !false
            // if(b == undefined){
                c = a + a;
            } else {
                c = a + b;
            }

            console.log('c: ',c);
            console.log('isNaN: ',isNaN(c));
            return c;
        }
        sum(1,2); //1이 a에 들어가고 2가 b에 들어감    전달인자
        sum('aaa',3);
        //전달인자를 하나만 줌
        //두번째 전달인자를 주지 않아서 undefined
        sum(1);
        sum('ㅁ');
        //아무것도 안줌
        sum();
        //전달인자 3개줌
        //많이 줘봤자 두개만 씀
        sum(1,2,5);

        //값을 안주면 무조건 0으로 계산하게 하는 sum2
        // function sum2 (a,b){
        //     if(a == undefined) a=0;
        //     if(b == undefined) b=0;

        //     return a+b; 
        // }

        function sum2 (a,b){
            if(a == undefined) a = 10;
            if(b == undefined) b = 20;

            return a+b; 
        }

        //전달인자가 없는 경우 초기값(기본값) 지정
        //아래처럼 쓰는건 아무것도 안줬을 경우를 대비해서
         function sum3 (a=10, b=20){
             return a+b;
         }
         let result2 = sum3();
        // console.log('sum3() 호출결과 :', result2);  //30
        // console.log('sum3() 호출결과 :', sum3(50)); //70
        // // 50은 첫번째 전달인자니까 a가 50이 됨 a가 없을 때만 10인데 a값을 넣어줬으니까
        // console.log('sum3() 호출결과 :', sum3(50,60)); //110

        // function sum4(){
        // //arguments : 전달인자 모두를 배열로 받기
        // //arguments가 임의로 지정해둔 이름이 아니고 전달인자를 배열로 받을 때 사용하는 키워드
           
        //     console.log(arguments);

        //     for(let i=0;arguments.length;i++){
        //         console.log(i, arguments[i])
        //     }
        // }
        // sum4(1,2,3,4); 
        // //Arguments(4) [1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ]

        // // ...: 스프레드 spread 연산자 ...만 쓰면 안되고 뒤에 변수명 작성해야함
        // //      지정하지 않는 arguments들을 배열처리 해줌
        // //      마지막 전달인자에만 적용할 수 있다
        // //splice(2,4,'a','b','c') 처럼 
        // function sum5(start, count, ...el){ //el은 변수명이니까 아무거나 상관없음 배열의요소element
        //     console.log(start, count, el);
        // }
        // sum5(1,2,3,4,5);

        // let aa = [100,200];
        // console.log(aa);

        // // console.log(100,200);
        // console.log(...aa);

        // //sum(aa[0],aa[1]);
        // sum(...aa);

    //     let a5 = "console.log(123)";
    //    eval(a5); //글씨를 javascript로 실행해줌
    //    eval("let a"+6 +'=60');

    //     //javascript의 변수에는 아무거나 담을 수 있다. 심지어 함수도
    //     let sum55= sum5;
    //     sum55(2,3,4,5);
    //     let cLog = console.log;
    //     cLog(12345);

    //     function sum5(){
    //         console.log('올 뉴 sum5');
    //    }
    //    sum5();

    //     console.log('before',typeof sum5);
    //     sum5 = 1;   //함수명도 변수 취급하기 때문에 이런경우 sum5는 그냥 1을 담은 변수가 된다
    //    // sum5(1,2) sum5는 더 이상 함수가 아님
    //    console.log('after',typeof sum5);

       function minus(x,y){
            console.log('minus 실행')
            return x-y;
             }

       // 전달인자로 함수를 전달할 수 있다
       // 콜백함수 CB for call back 
       function study(cb){
            console.log('1~2시간 정도 공부함')

            if(typeof cb== "function"){
                let remain = cb(10,2);
                console.log('남은 공부시간', remain);
            }

       }
       study(minus);

    //익명함수 anonymous 
    //이름이없다
    let fn1 = function(){
        console.log('fn1 실행');
    }

    //예를 들어
    //이런 함수가 콜백으로 딱 한번밖에 안쓰이는 경우
    function times(a,b){
        return a*b;
    }
    
    study(times); //이렇게 할 수도 있는데

    let times2 = times; //times2라는 변수에 times를 넣고
    study(times2);

    let times3 = function(a,b){ //times3는 익명함수?
        return a*b;
    }
    study(times3);

    study( function(a,b){
        return a*b;
    })

    //n초 있다가 실행해라 
    // setTimeout: 첫번째 전달인자로 실행할 함수
    //             두번째 번달인자로 1/1000초 단위의 시간을 전달
    // 정해진 시간 이후 딱 한번만 실행됨
    // 두번째 전달인자 시간 이후에 callback 실행
    // 실행하면 예약번호를 return

    //setTimeout(fn1, 3*1000); 
    //3초 있다가 fn1실행해 
 
    // setTimeout(function (){
    //     console.log('fn1 실행');
    // }, 3*1000);
    
    let idx = setTimeout(function (){ //--예약을 거는 행위
        console.log('fn1 실행');
    }, 3*1000);
    //24*60*60*1000

    console.log('idx: ',idx);
    //예약한 내용 취소 
    clearTimeout(idx); 

    // 지정된 ms(밀리세컨드) 이후마다 반복해서 callback 함수 실행
    let idx2 = setInterval(function (){
         console.log('setInterval 실행');
     }, 1*1000);

    setTimeout(function(){
        console.log('setInterval 종료')
        clearInterval(idx2)
    }, 2.5*1000) //두번만 실행되고 종료

    console.log(new Date().getTime())

    let test = function test(a,b){
        console.log(a,b);
        return a;
        }
    //화살표 함수 arrow function =>
    let test1 = (a,b) => {
        console.log(a,b);
        return a;
    }
    let test2 = (a) => {
        console.log(a,b);
        return a;
        }
    //전달인자가 하나만 있는 경우
    //파라미터의 주변 괄호를 생략할 수 있다
    let test3 = a => {
        console.log(a,b);
        return a+b;
    }
    //전달인자가 없다면 하나가 아니니까 ()생략 불가능
    let test3_1 = () => {}

    let test4 = (a,b) => {
        return a+b;
    }

    //함수의 실행블럭 내용이 return문만 있는 경우
    // 'return'키워드와 {}생략할 수 있음
    // {}가 없는 경우 return 생략은 필수
    let test5 = (a,b) => a+b;

    let test6 = a => a*3;

    study(a => a*3);
    
    </script>
</head>
<body>
    
</body>
</html>